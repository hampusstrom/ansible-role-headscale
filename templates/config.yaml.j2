---
# headscale will look for a configuration file named `config.yaml` (or `config.json`) in the following order:
#
# - `/etc/headscale`
# - `~/.headscale`
# - current working directory

# The url clients will connect to.
# Typically this will be a domain like:
#
#  https://headscale.example.com:443
#
server_url: {{ headscale_server_url }}

# Address to listen to / bind to on the server
#
# For production:d
# listen_addr: 0.0.0.0:8080
listen_addr: {{ headscale_listen_addr }}

# Address to listen to /metrics, you may want
# to keep this endpoint private to your internal
# network
#
metrics_listen_addr: {{ headscale_metrics_listen_addr}}

# Address to listen for gRPC.
# gRPC is used for controlling a headscale server
# remotely with the CLI
# Note: Remote access _only_ works if you have
# valid certificates.
#
# For production:
# grpc_listen_addr: 0.0.0.0:50443
grpc_listen_addr: {{ headscale_grpc_listen_addr }}

# Allow the gRPC admin interface to run in INSECURE
# mode. This is not recommended as the traffic will
# be unencrypted. Only enable if you know what you
# are doing.
grpc_allow_insecure: {{ headscale_grpc_allow_insecure }}

# Private key used to encrypt the traffic between headscale
# and Tailscale clients.
# The private key file will be autogenerated if it's missing.
#
# For production:
# /var/lib/headscale/private.key
private_key_path: {{ headscale_private_key_path }}

# The Noise section includes specific configuration for the
# TS2021 Noise protocol
noise:
  # The Noise private key is used to encrypt the
  # traffic between headscale and Tailscale clients when
  # using the new Noise-based protocol. It must be different
  # from the legacy private key.
  #
  # For production:
  # private_key_path: /var/lib/headscale/noise_private.key
  private_key_path: {{ headscale_noise_private_key_path }}

# List of IP prefixes to allocate tailaddresses from.
# Each prefix consists of either an IPv4 or IPv6 address,
# and the associated prefix length, delimited by a slash.
ip_prefixes:
{% for prefix in headscale_ip_prefixes %}
  - {{ prefix }}
{% endfor %}

# DERP is a relay system that Tailscale uses when a direct
# connection cannot be established.
# https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp
#
# headscale needs a list of DERP servers that can be presented
# to the clients.
derp:
  server:
    # If enabled, runs the embedded DERP server and merges it into the rest of the DERP config
    # The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place
    enabled: {{ headscale_derp_server_enabled }}

    # Region ID to use for the embedded DERP server.
    # The local DERP prevails if the region ID collides with other region ID coming from
    # the regular DERP config.
    region_id: {{ headscale_derp_server_region_id }}

    # Region code and name are displayed in the Tailscale UI to identify a DERP region
    region_code: {{ headscale_derp_server_region_code }}
    region_name: {{ headscale_derp_server_region_name }}

    # Listens over UDP at the configured address for STUN connections - to help with NAT traversal.
    # When the embedded DERP server is enabled stun_listen_addr MUST be defined.
    #
    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/
    stun_listen_addr: {{ headscale_derp_server_stun_listen_addr }}

  # List of externally available DERP maps encoded in JSON
  urls:
{% for derp_url in headscale_derp_urls %}
    - {{ derp_url }}
{% endfor %}

  # Locally available DERP map files encoded in YAML
  #
  # This option is mostly interesting for people hosting
  # their own DERP servers:
  # https://tailscale.com/kb/1118/custom-derp-servers/
  #
  # paths:
  #   - /etc/headscale/derp-example.yaml
{% if headscale_derp_paths == None or headscale_derp_paths is not defined%}
  paths: []
{% else %}
  paths:
{% for derp_path in headscale_derp_paths%}
    - {{ derp_path }}
{% endfor %}
{% endif %}

  # If enabled, a worker will be set up to periodically
  # refresh the given sources and update the derpmap
  # will be set up.
  auto_update_enabled: {{ headscale_derp_auto_update_enabled }}

  # How often should we check for DERP updates?
  update_frequency: {{ headscale_derp_update_frequency }}

# Disables the automatic check for headscale updates on startup
disable_check_updates: {{ headscale_disable_check_updates }}

# Time before an inactive ephemeral node is deleted?
ephemeral_node_inactivity_timeout: {{ headscale_ephemeral_inactivity_timeout }}

# Period to check for node updates within the tailnet. A value too low will severely affect
# CPU consumption of Headscale. A value too high (over 60s) will cause problems
# for the nodes, as they won't get updates or keep alive messages frequently enough.
# In case of doubts, do not touch the default 10s.
node_update_check_interval: {{ headscale_node_update_check_interval }}

# Database Config
db_type: {{ headscale_db_type }}
{% if headscale_db_type == 'sqlite3' %}
db_path: {{ headscale_db_path }}
{% else %}
# If using a Unix socket to connect to Postgres, set the socket path in the 'host' field and leave 'port' blank.
db_host: {{ headscale_db_host }}
db_port: {{ headscale_db_port }}
db_name: {{ headscale_db_name }}
db_user: {{ headscale_db_user }}
db_pass: {{ headscale_db_pass }}
db_ssl: {{ headscale_db_ssl }}
{% endif %}

### TLS configuration
#
## Let's encrypt / ACME
#
# headscale supports automatically requesting and setting up
# TLS for a domain with Let's Encrypt.
#
# URL to ACME directory
acme_url: {{ headscale_acme_url }}

# Email to register with ACME provider
acme_email: "{{ headscale_acme_email }}"

# Domain name to request a TLS certificate for:
tls_letsencrypt_hostname: "{{ headscale_tls_letsencrypt_hostname }}"

# Client (Tailscale/Browser) authentication mode (mTLS)
# Acceptable values:
# - disabled: client authentication disabled
# - relaxed: client certificate is required but not verified
# - enforced: client certificate is required and verified
tls_client_auth_mode: {{ headscale_tls_client_auth_mode }}

# Path to store certificates and metadata needed by
# letsencrypt
# For production:
# tls_letsencrypt_cache_dir: /var/lib/headscale/cache
tls_letsencrypt_cache_dir: {{ headscale_tls_letsencrypt_cache_dir }}

# Type of ACME challenge to use, currently supported types:
# HTTP-01 or TLS-ALPN-01
# See [docs/tls.md](docs/tls.md) for more information
tls_letsencrypt_challenge_type: {{ headscale_tls_letsencrypt_challenge_type }}
# When HTTP-01 challenge is chosen, letsencrypt must set up a
# verification endpoint, and it will be listening on:
# :http = port 80
tls_letsencrypt_listen: "{{ headscale_tls_letsencrypt_listen }}"

## Use already defined certificates:
tls_cert_path: "{{ headscale_tls_cert_path }}"
tls_key_path: "{{ headscale_tls_key_path }}"

log:
  # Output formatting for logs: text or json
  format: {{ headscale_log_format }}
  level: {{ headscale_log_level }}

# Path to a file containg ACL policies.
# ACLs can be defined as YAML or HUJSON.
# https://tailscale.com/kb/1018/acls/
acl_policy_path: "{{ headscale_acl_policy_path }}"

## DNS
#
# headscale supports Tailscale's DNS configuration and MagicDNS.
# Please have a look to their KB to better understand the concepts:
#
# - https://tailscale.com/kb/1054/dns/
# - https://tailscale.com/kb/1081/magicdns/
# - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/
#
dns_config:
  # Whether to prefer using Headscale provided DNS or use local.
  override_local_dns: {{ headscale_dns_config_override_local_dns }}

  # List of DNS servers to expose to clients.
  nameservers:
{% for nameserver in headscale_dns_config_nameservers %}
    - {{ nameserver }}
{% endfor %}

  # NextDNS (see https://tailscale.com/kb/1218/nextdns/).
  # "abc123" is example NextDNS ID, replace with yours.
  #
  # With metadata sharing:
  # nameservers:
  #   - https://dns.nextdns.io/abc123
  #
  # Without metadata sharing:
  # nameservers:
  #   - 2a07:a8c0::ab:c123
  #   - 2a07:a8c1::ab:c123

  # Split DNS (see https://tailscale.com/kb/1054/dns/),
  # list of search domains and the DNS to query for each one.
  #
  # restricted_nameservers:
  #   foo.bar.com:
  #     - 1.1.1.1
  #   darp.headscale.net:
  #     - 1.1.1.1
  #     - 8.8.8.8
{% if headscale_dns_config_restricted_nameservers is defined and headscale_dns_config_restricted_nameservers != None%}
  restricted_nameservers:
{% for splitdns in headscale_dns_config_restricted_nameservers %}
    {{ splitdns.domain }}:
{% for dns_server in splitdns.dns_servers %}
      - {{ dns_server }}
{% endfor %}
{% endfor %}
{% endif %}

  # Search domains to inject.
  domains: {{ headscale_dns_config_domains }}

  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).
  # Only works if there is at least a nameserver defined.
  magic_dns: {{ headscale_dns_config_magic_dns }}

  # Defines the base domain to create the hostnames for MagicDNS.
  # `base_domain` must be a FQDNs, without the trailing dot.
  # The FQDN of the hosts will be
  # `hostname.namespace.base_domain` (e.g., _myhost.mynamespace.example.com_).
  base_domain: {{ headscale_dns_config_base_domain }}

# Unix socket used for the CLI to connect without authentication
# Note: for production you will want to set this to something like:
# unix_socket: /var/run/headscale.sock
unix_socket: {{ headscale_unix_socket }}
unix_socket_permission: "{{ headscale_unix_socket_permission }}"

#
# headscale supports experimental OpenID connect support,
# it is still being tested and might have some bugs, please
# help us test it.
# OpenID Connect
{% if headscale_oidc_enabled %}
oidc:
   only_start_if_oidc_is_available: {{ headscale_oidc_only_start_if_oidc_is_available }}
   issuer: {{ headscale_oidc_issuer }}
   client_id: {{ headscale_oidc_client_id }}
   client_secret: {{ headscale_oidc_client_secret }}

#
#   Customize the scopes used in the OIDC flow, defaults to "openid", "profile" and "email" and add custom query
#   parameters to the Authorize Endpoint request. Scopes default to "openid", "profile" and "email".
#
   scope: {{ headscale_oidc_scope }}
{% if headscale_oidc_extra_params is defined and headscale_oidc_extra_params != None %}
   extra_params:
{% for param in headscale_oidc_extra_params %}
    {{ param.key }}: {{ param.value }}
{% endfor %}
{% endif %}

#
#   List allowed principal domains and/or users. If an authenticated user's domain is not in this list, the
#   authentication request will be rejected.
#
#   allowed_domains:
#     - example.com
#   allowed_users:
#     - alice@example.com
#
{% if headscale_oidc_allowed_domains is defined and headscale_oidc_allowed_domains != None %}
  allowed_domains:
{% for domain in headscale_oidc_allowed_domains %}
    - {{ domain }}
{% endfor %}
{% endif %}
{% if headscale_oidc_allowed_users is defined and headscale_oidc_allowed_users != None %}
  allowed_users:
{% for user in headscale_oidc_allowed_users %}
    - {{ user }}
{% endfor %}
{% endif %}


#   If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.
#   This will transform `first-name.last-name@example.com` to the namespace `first-name.last-name`
#   If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following
#   namespace: `first-name.last-name.example.com`
#
#   strip_email_domain: true
  namespace: `{{ headscale_oidc_namespace }}`

  strip_email_domain: {{ headscale_oidc_strip_email_domain }}
{% endif %}


# Logtail configuration
# Logtail is Tailscales logging and auditing infrastructure, it allows the control panel
# to instruct tailscale nodes to log their activity to a remote server.
logtail:
  # Enable logtail for this headscales clients.
  # As there is currently no support for overriding the log server in headscale, this is
  # disabled by default. Enabling this will make your clients send logs to Tailscale Inc.
  enabled: {{ headscale_logtail_enabled }}

# Enabling this option makes devices prefer a random port for WireGuard traffic over the
# default static port 41641. This option is intended as a workaround for some buggy
# firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.
randomize_client_port: {{ headscale_randomize_client_port }}
